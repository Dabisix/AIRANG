'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Recorder = _react2.default.createClass({
  displayName: 'Recorder',
  start: function start() {
    this.mediaRecorder.start();
  },
  stop: function stop() {
    this.mediaRecorder.stop();
  },
  pause: function pause() {
    this.mediaRecorder.pause();
  },
  resume: function resume() {
    this.mediaRecorder.resume();
  },
  componentDidMount: function componentDidMount() {
    var _this = this;

    navigator.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.webkitGetUserMedia;

    if (navigator.getUserMedia && window.MediaRecorder) {
      (function () {
        var constraints = { audio: true };
        _this.chunks = [];
        var _props = _this.props;
        var blobOpts = _props.blobOpts;
        var onStop = _props.onStop;
        var onError = _props.onError;
        var mediaOpts = _props.mediaOpts;
        var onPause = _props.onPause;
        var onResume = _props.onResume;
        var onStart = _props.onStart;
        var gotStream = _props.gotStream;


        var onErr = function onErr(err) {
          console.warn(err);
          if (onError) onError(err);
        };

        var onSuccess = function onSuccess(stream) {
          _this.mediaRecorder = new window.MediaRecorder(stream, mediaOpts || {});

          _this.mediaRecorder.ondataavailable = function (e) {
            _this.chunks.push(e.data);
          };

          _this.mediaRecorder.onstop = function (e) {
            var blob = new window.Blob(_this.chunks, blobOpts || { type: 'audio/wav' });
            _this.chunks = [];
            onStop(blob);
          };

          _this.mediaRecorder.onerror = onErr;
          if (onPause) _this.mediaRecorder.onpause = onPause;
          if (onResume) _this.mediaRecorder.onresume = onResume;
          if (onStart) _this.mediaRecorder.onstart = onStart;
          _this.stream = stream;
          if (gotStream) gotStream(stream);
        };

        navigator.getUserMedia(constraints, onSuccess, onErr);
      })();
    } else {
      console.warn('Audio recording APIs not supported by this browser');
      var onMissingAPIs = this.props.onMissingAPIs;

      if (onMissingAPIs) {
        onMissingAPIs(navigator.getUserMedia, window.MediaRecorder);
      } else {
        window.alert('Your browser doesn\'t support native microphone recording. For best results, we recommend using Google Chrome or Mozilla Firefox to use this site.');
      }
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    if (this.props.command && this.props.command !== 'none' && prevProps.command !== this.props.command) {
      this[this.props.command]();
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount(this.stream);
  },
  render: function render() {
    return false;
  },


  propTypes: {
    command: _react.PropTypes.oneOf(['start', 'stop', 'pause', 'resume', 'none']),
    onStop: _react.PropTypes.func.isRequired,
    onMissingAPIs: _react.PropTypes.func,
    onError: _react.PropTypes.func,
    onPause: _react.PropTypes.func,
    onStart: _react.PropTypes.func,
    onResume: _react.PropTypes.func,
    onUnmount: _react.PropTypes.func,
    gotStream: _react.PropTypes.func,
    blobOpts: _react.PropTypes.object,
    mediaOpts: _react.PropTypes.object
  }
});

exports.default = Recorder;